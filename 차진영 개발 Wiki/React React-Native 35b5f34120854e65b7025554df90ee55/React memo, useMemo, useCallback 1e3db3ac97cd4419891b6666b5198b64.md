# React.memo, useMemo, useCallback

`useMemo`와 `useCallback`은 **메모이제이션** 개념을 사용한 React 성능 최적화 **hook**이다.

모두 **의존성 변수**를 지정하여 해당 값의 변화가 일어날 때 작업을 처리한다.

**장점**

- **리렌더링 최소화**로 인한 성능 개선
- **불필요한 연산**을 방지하여 성능 개선

**단점**

- 과도한 사용 시 **메모리 사용**으로 인한 성능 저하

`React.memo`

```tsx
const MyComponent = React.memo(({ count }) => {
  return <div>{count}</div>;
});
```

컴포넌트의 **props가 변경되지 않으면** 다시 렌더링되지 않도록 한다.

**사용하지 말아야 하는 경우**

1. **컴포넌트**가 자주 변경되는 경우
    
    ⇒ props가 자주 변경되거나 동적으로 변경되는 경우, 비교 작업 자체가 성능에 부담
    
2. **컴포넌트**가 **렌더링**에 큰 비용이 들지 않는 경우
3. `props` 변경을 깊게 비교해야 하는 경우
    
    ⇒ **얕은 비교**를 사용하여 확인하기 때문에 객체의 **참조**가 변경되지 않으면 렌더링 방지
    
4. **context API**를 사용할 때
    
    ⇒ `context` 값이 변경될 경우, 해당 값을 사용하는 모든 컴포넌트가 **리렌더링**
    

### **메모이제이션(Memoization)**

수행한 연산 결과를 메모리에 저장해두고 이후 동일한 입력에 대해 결과를 재사용하는 방법

`useMemo`

```jsx
const getMemoized = useMemo(() => {
	return a * b * c;
}, [a, b]);
```

**의존성 변수**가 변경될 때까지 **메모이제이션** 결과를 반환한다.

위의 예시에서 a와 b 값이 변할 때는 새로운 결과를 반환하지만 c 값이 변할 때는 **메모이제이션** 결과를 반환한다.

1. `state` 값이 변경되면 **리렌더링**이 발생
    
    **⇒ 컴포넌트** 내의 모든 연산이 다시 처리가 되어 성능 저하
    
2. `useMemo`를 위의 예시와 같이 사용하면 a, b가 변경될 때만 연산을 다시 수행하기 때문에 성능 개선

`*useCallback*`

```jsx
const getMemoizedCallback = useCallback(() => {
	onClick();
}, [onClick]);
```

**메모이제이션된 함수**를 반환한다.

⇒ `useMemo`를 사용해도 기존 함수와 생성한 함수의 **reference**가 달라 리렌더링 발생하기 때문에 사용

**사용용도**

- 함수가 **자식 컴포넌트**에 `props`로 전달될 때, **리렌더링**을 방지
- API 호출 함수를 사용했을 때, **리렌더링**으로 인한 **무한루프** 방지